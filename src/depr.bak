
// impl IterAll {
//     pub fn filter_entry<P>(self, predicate: P) -> IterFilter<Self, P>
//     where
//         P: FnMut(&path::Path) -> bool,
//     {
//         IterFilter {
//             iter: self,
//             predicate,
//         }
//     }
// }

// TODO: it is not possible to change the underlying iterator and thus use the filter_predicate
// function of `walkdir` for the original IterAll, but a similar pattern and recursive iterator
// can be implemented here -> but didn't work.

// #[derive(Debug)]
// pub struct IterFilter<I, P> {
//     iter: I,
//     predicate: P,
// }

// impl<P> Iterator for IterFilter<IterAll, P>
// where
//     P: FnMut(&path::Path) -> bool,
// {
//     type Item = Result<path::PathBuf, Error>;

//     fn next(&mut self) -> Option<Self::Item> {
//         loop {
//             let entry = match self.iter.next() {
//                 None => return None,
//                 Some(result) => match result {
//                     Ok(v) => v,
//                     Err(err) => return Some(Err(From::from(err))),
//                 },
//             };
//             if !(self.predicate)(&entry) {
//                 continue;
//             }
//             return Some(Ok(entry));
//         }
//     }
// }

// impl<P> IterFilter<IterAll, P>
// where
//     P: FnMut(&path::Path) -> bool,
// {
//     pub fn filter_entry(self, predicate: P) -> IterFilter<Self, P> {
//         IterFilter {
//             iter: self,
//             predicate,
//         }
//     }
// }

let paths: Vec<_> = builder
            .into_iter()
            // .filter_entry(|p| !{
            //     p.file_name()
            //         .unwrap_or_else(|| p.as_os_str())
            //         .to_str()
            //         .map(|s| s.starts_with("."))
            //         .unwrap_or(false)
            // })
            // .filter_entry(|q: &path::Path| true) // TODO: still doesn't work
            .flatten()
            .filter(|p| !is_hidden(p))
            // .filter(|_p| true)
            .collect();